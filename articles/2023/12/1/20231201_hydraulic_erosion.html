<!DOCTYPE HTML>
<html>

<head>
    <meta charset="utf-8">
    <title>
        Hydraulic Erosion on Virtual Terrain
    </title>
    <link rel="stylesheet" type="text/css" href="/static/style/article.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Taviraj&family=Work+Sans&display=swap" rel="stylesheet">
    <link href="https://pvinis.github.io/iosevka-webfont/3.4.1/iosevka.css" rel="stylesheet" />

    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/base16/gigavolt.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>


    <script type="text/javascript" src="https://notabug.org/Ash/highlightjs-zig/raw/85472160e62a0aa0a455a4f16853f0be993e2882/dist/zig.min.js"></script>

    <script type="text/javascript">
        hljs.highlightAll();
    </script>
</head>

<body>
    <div class="bg-image"></div>
    <div id="page-wrapper">
        <div id="banner">
            <a href="/">
                <svg class="arrow">
                    <image href="/static/img/templates/arrow_neg.svg" />
                </svg>
                <span>home</span>
            </a>
        </div>
        <div id="article-body">
            <div id="article-title">
                Hydraulic Erosion on Virtual Terrain
            </div>
            <p>This is a neat little technique for procedural terrain that I had seen a few other people show off online.  I always though it looked really cool so I decided to implement a version of it myself.</p><p>In nature, when there is a bunch of water that comes into contact with a surface over time, it will gradually carve out interesting looking erosion patterns.  This is because the water picks up microscopic pieces of the rock or soil and then moves them somewhere else.  This is called <em>hydraulic erosion</em>.</p><p><img src="res/erosion.jpg" title=""></p><p>We can imitate this process on virtual terrain by simulating water that modifies the terrain&#39;s height as it moves, kind of resembling how sediment shifts around on real terrain.</p><p>I was also looking for an excuse to try out <a href="https://ziglang.org/" title="">Zig</a>, so that is what I will be using to implement the project.  Don&#39;t worry if you&#39;re not familiar with Zig, all of the code snippets should still be readable, and I&#39;ve quarantined my thoughts about the language to a short section at the end.</p><p>A lot of the code in this write-up has been simplified to be as readable as possible, but if you actually want to read through the source, it&#39;s available on my GitHub <a href="https://github.com/jehoz/TerrainGen" title="">here</a>.</p><h1>Before we start</h1><p>It won&#39;t be very exciting if we just try to erode a flat plane, so we&#39;ll need to start off with some initial topography. If you&#39;ve ever played around with procedural generation, you probably know that it&#39;s very easy to get some serviceable looking terrain just by using some kind of 2D noise as a heightmap, and we&#39;ll be doing exactly that. I am using ridged simplex noise for the in most of the demo images/videos below, but the type of noise isn&#39;t that important, we just need some basic peaks and valleys to work with.</p><p>The heightmap is rendered to a texture and send to the GPU. Then we have a vertex shader that deforms a flat mesh according to the values in the heightmap, which gives us something that looks like this:</p><p><img src="res/01.png" title=""></p><h2>A slightly better data structure</h2><p>Any heightmap we generate is necessarily going to be a discrete 2D array of values.</p><p>This is usually fine because you just want a heightmap to displace the z-coordinates of mesh&#39;s vertices, and because the mesh is a mesh, the edges will smoothly interpolate between the values in the heightmap, giving the final result the appearance of being continuous.</p><p>But in our case we actually want our heightmap to be continuous (or at least act like it) while we&#39;re working with it on the CPU.  We need to compute the motion of water sliding down the hills of our terrain, and this is going to be a lot easier if we can sample the height and slope of any non-discrete point on our surface.</p><p>So instead of directly dealing with the array of height values, I wrapped it in an abstraction that does some bilinear interpolation under the hood, which should make our lives a little easier.</p><pre><code class="language-zig">const ScalarField = struct {
	// leaving out most of the implementation for brevity

	/// Get the value of a given point on the field
	/// (bilinearly interpolated from the four surrounding cells)
	pub fn get(self: ScalarField, pos: Vector2) f32 {
		...
	}

	/// Get the slope/gradient of a given point on the field
	pub fn gradient(self: ScalarField, pos: Vector2) Vector2 {
		...
	}

	/// Modify the value of a given point on the field
	/// (delta is distributed across the four surrounding cells)
	pub fn modify(self: ScalarField, pos: Vector2, delta: f32) void {
		...
	}
};
</code></pre><h1>Simulating water</h1><p>We&#39;ll be going with the typical &quot;particle-based&quot; approach here (although there are some <a href="https://xing-mei.github.io/files/erosion.pdf" title="">neat alternatives</a> that are also worth reading into).</p><p>The idea is that you randomly spawn a bunch of water droplets (or &quot;particles&quot;) all over and have them individually erode bits of the terrain.  Each one moves only a small amount of sediment, but in large quantities, they carve out patterns that are reminiscent of real life hydraulic erosion.</p><h2>The life of a water droplet</h2><p>In the code, a droplet of water looks like this:</p><pre><code class="language-zig">const WaterDroplet = struct {
    position: Vector2,
    velocity: Vector2 = .{ .x = 0, .y = 0 },
    volume: f32 = 1,
    sediment: f32 = 0,

    pub fn init(pos: Vector2) WaterDroplet {
        return .{ .position = pos };
    }
};
</code></pre><p>And this is what it does throughout the course of its life:</p><pre><code class="language-zig">var drop = WaterDroplet.init(.{
	.x = random.float(f32) * width,
	.y = random.float(f32) * height,
});

while (drop.volume &gt; opts.min_volume) {
	// Movement
	...

	// Sediment transfer
	...

	drop.volume *= 1 - opts.droplet_evaporation;
}
</code></pre><p>A droplet is spawned somewhere on the surface of our terrain.  It moves, transfers some sediment and shrinks down a little bit. Once its volume gets too small, we throw the it in the trash and move on to the next one.</p><p><code>opts</code> refers to an <code>ErosionOptions</code> struct that gets passed into our erode function. It holds all of the &quot;tweakable knobs&quot; for our simulation. You can see here that two of those knobs control how small the droplet is allowed to get before we drop it (<code>min_volume</code>), and how much the volume decreases every step (<code>droplet_evaporation</code>).<br>Now let&#39;s look at what actually happens inside that loop.</p><h2>Movement</h2><p>First thing we do every step is compute the particle&#39;s movement with some extremely bastardized kinematics.</p><pre><code class="language-zig">const grav_force = self.elevation.gradient(drop.position).scale(opts.gravity);
drop.velocity = drop.velocity.scale(1 - opts.friction).subtract(grav_force);
drop.position = drop.position.add(drop.velocity.normalize());
</code></pre><p>As you can see, we&#39;re not trying to be very scientifically accurate. We also have two more knobs.  <code>gravity</code> and <code>friction</code> are parameters that affect how much the slope impacts the velocity, and how much velocity degrades over time, respectively. We always move the droplet one unit in whatever direction so that we&#39;re not stuck in the same place for too long nor are we skipping over intermediate cells if our droplet starts moving too fast.</p><p>You can get fancy with this part and implement a more accurate rigid-body physics simulation, but I found that doing it this way works perfectly fine.</p><h2>Sediment transfer</h2><p>Before we get into the exact implementation of this step, let&#39;s look at what it&#39;s doing.</p><pre><code class="language-zig">const delta_sed = // pretend this is calculated somehow

drop.sediment -= delta_sed;
self.elevation.modify(init_pos, delta_sed);
</code></pre><p>This should be pretty easy to understand.  We calculate the amount of sediment to move (negative for erosion, positive for deposition) and then transfer it from the terrain to the droplet or vice versa.  There is no hard and fast rule for how you have to compute <code>delta_sed</code> (everyone seems to do it a little differently), but it&#39;s important to get it right or the simulation will spiral out of control.</p><p>Initially I calculated a &quot;maximum sediment capacity&quot; for the water droplet, and then computed <code>delta_sed</code> as the difference between the droplet&#39;s held sediment and this capacity.</p><pre><code class="language-zig">const delta_elev = self.elevation.get(drop.position) - self.elevation.get(init_pos);
var max_sed = drop.velocity.length() * drop.volume * delta_elev * opts.sed_capacity;
max_sed = @max(0, max_sed);

const delta_sed = (max_sed - drop.sediment) * opts.sediment_transfer_rate;
</code></pre><p>This technique works pretty well, but you will occasionally get big spikes or deep pits that form because <code>delta_sed</code> becomes too extreme. I found the best way to address this is to constrain <code>delta_sed</code> so that it never erodes or deposits more than the droplet&#39;s change in elevation.</p><pre><code class="language-zig">const delta_sed =
	smaller(delta_elev, max_sed - drop.sediment) * opts.sediment_transfer_rate;
</code></pre><p>(using this helper function that just returns whichever argument is closer to zero)</p><pre><code class="language-zig">fn smaller(x: anytype, y: anytype) @TypeOf(x, y) {
    if (@fabs(x) &lt; @fabs(y)) {
        return x;
    } else {
        return y;
    }
}
</code></pre><p>At this point the erosion was working like a charm, but after doing some experimenting, I figured out that this whole part can be simplified without any distinguishable difference in the output. I measured a few runs (each with different parameters) and in each one, <code>delta_elev</code> ended up being smaller than <code>max_sed - drop.sediment</code> over 99% of the time!</p><p>So instead we can scrap the maximum sediment and just set <code>delta_sed</code> to the change in elevation (multiplied by a small &quot;transfer rate&quot; coefficient).  And when we do that we no longer need to track how much sediment the droplet is carrying.  Here is what our code looks like now:</p><pre><code class="language-zig">const delta_elev = self.elevation.get(drop.position) - self.elevation.get(init_pos);
var delta_sed = delta_elev * opts.sediment_transfer_rate;

self.elevation.modify(init_pos, delta_sed);
</code></pre><p>We&#39;ve diverted a bit from the realism of the simulation, but I personally don&#39;t care about that very much as long as the results still look good.</p><h3>One last touch</h3><p>We can also adjust the the amount of sediment that is deposited versus the amount that is eroded if we want to control how much the terrain &quot;fills up&quot;.</p><pre><code class="language-zig">if (delta_sed &gt; 0) delta_sed *= opts.sediment_ratio;
self.elevation.modify(init_pos, delta_sed);
</code></pre><p>This part isn&#39;t super necessary, but it grants us an extra dimension of creative control, which is always good in my opinion.</p><h2>Rendering</h2><p>Finally here is a demo of everything in action:</p><video controls>
    <source src="res/02.webm" type="video/webm; codecs=vp9;vorbis">
</video>
<p>I don&#39;t know about you but I think this already looks pretty cool. You should immediately be able to pick out some characteristic features of this technique: grooves forming along the slopes (these are called rills or gullies) and valleys filling up into flat planes.</p><p>A common trick you will see done with terrain is to render it with a shader that colors/textures the mesh differently according to how &quot;flat&quot; it is at each point — more horizontal parts are rendered as grass and more vertical parts are rendered as rock or dirt.</p><p><img src="res/03.png" title=""></p><p>This looks nice, but I think it would look better if we added some variety to the flat green color.</p><h1>Moisture</h1><p>This is an approach I didn&#39;t see in the other hydraulic erosion sims I peeked at (although surely someone has done it before).  Naturally water doesn&#39;t just move sediment around, it also makes it <em>wet</em>, and parts of the ground that see more waterflow are typically more wet than other parts.</p><p>We&#39;ll create another <code>ScalarField</code> to keep track of the moisture level throughout our terrain and then add the following code to our loop:</p><pre><code class="language-zig">const inv_speed = @max(0, 1 - drop.velocity.length());
const inv_saturation = @max(0, 1 - self.moisture.get(drop.position));
const delta_moisture = inv_speed * inv_saturation * opts.soil_absorption;

self.moisture.modify(drop.position, delta_moisture);
</code></pre><p>We want the added moisture to roughly correspond to the &quot;amount of time&quot; a droplet spends at each point along its path.  Obviously we haven&#39;t been using fixed time steps (see the movement section above), so we use an &quot;inverse speed&quot; value here instead.  We also want the added moisture to scale inversely with how wet the terrain already is (this keeps the moisture levels from getting too splotchy and out of control).</p><p>After our droplet dies, we&#39;ll go though the entire terrain and &quot;evaporate&quot; a little bit of the moisture from the soil.</p><pre><code class="language-zig">for (self.moisture.data, 0..) |_, i| {
	self.moisture.data[i] *= 1 - opts.soil_evaporation;
}
</code></pre><p>Being able to tune the <code>soil_absorption</code> and <code>soil_evaporation</code> parameters is important for finding a good balanced level of moisture for a particular terrain.</p><h2>Rendering</h2><p>Now we can use the terrain&#39;s &quot;moisture map&quot; to add some visual interest to our landscape.</p><p>Wet soil tends to foster more plant life than dry soil (although this is a gross oversimplification) and when there is <em>a lot</em> of water in a particular spot, you might even expect rivers and lakes to form. In our fragment shader, instead of shading the ground a flat green, we can adjust the color based on the moisture level.  If you wanted more accurate formation of bodies of rivers and lakes you could implement some kind of fluid dynamics, but instead we&#39;re going to cheat (kind of) and pretend that any part of the ground above a certain moisture threshold &quot;is&quot; water and we&#39;ll color it blue.</p><p>I&#39;m also coloring the wet parts of the rock slightly darker so that the grooves have a bit more contrast.</p><video controls>
    <source src="res/04.webm" type="video/webm">
</video>
<p>In my opinion, this looks <em>way</em> better than flat green ground in the image above.</p><p>I even got a little crazy at the end and added some <s>trees</s> ambiguous foliage to the wet parts of the terrain with the magic of shell texturing (although it&#39;s a little hard to see unless you zoom in a bit).</p><p><img src="res/05.png" title=""> <img src="res/06.png" title=""></p><p>I&#39;m omitting all of my shader code from this write-up but feel free to check out the source if you&#39;re interested in how it all works.</p><h1>Gallery</h1><p>Here are a few different examples I generated to show off the variety you can get by just tweaking parameters and the initial heightmap.</p><p><img src="res/09.png" title=""> <img src="res/07.png" title=""> <img src="res/08.png" title=""> <img src="res/10.png" title=""> <img src="res/11.png" title=""></p><h1>Appendix: Thoughts on Zig</h1><p>Like I mentioned, part of why I started this entire thing was to play around with Zig.  I&#39;ve been casually keeping my eye on the language since around the time it popped up, but this is the first time I&#39;ve ever used it.</p><p>From what I can tell, Zig is trying to do something unique by specifically competing with C, <em>not</em> C++.  To this end, Zig is a rather minimalist language (kind of like Go) but one that seems to respect your competency as a computer programmer (unlike Go).  It feels a lot like writing C, but without several of the reoccurring headaches you get from writing in C. The downside, though, is that in its current state it adds plenty of its own headaches that kind of ruin the experience.</p><p>I have nitpicks with some of the language design choices, but these are easy to cope with. The real problem is that Zig is still so young (version 0.11.0 as of writing this) and there is a severe lack of good documentation.  Significant parts of the language, standard library, and build system are still in flux, with new versions often breaking backwards compatibility.  A handful of times I found an example of code that did what I wanted, but wouldn&#39;t compile.  Then I had to dig around and find the relevant discussion on a GitHub issue that explained why that API changed and what it was changed to.</p><p>That all being said, I actually like Zig and its design philosophy for the most part.  It&#39;s just currently in a state where using it to any serious capacity means you have to stay up to date with the bleeding edge of the language&#39;s development.</p><p>I imagine most of the sharp edges will get smoothed out come 1.0, and I&#39;m very excited to see what the language looks like at that point.  But until then, I will probably just watch from afar.</p>
        </div>
        <div id="spacer"></div>
        <div class="marquee">
            <div id="footer-inner">
                <span class="marquee-item">
                    <span>
                        thank you for reading
                    </span>
                    <img src="/static/img/templates/heart.gif"></img>
                </span>
                <span class="marquee-item">
                    <span>
                        please come back soon
                    </span>
                    <img src="/static/img/templates/wave.gif"></img>
                </span>
            </div>
            <script type="text/javascript">
                // duplicate the spans in the footer marquee 8 times
                let footer = document.getElementById("footer-inner");
                footer.innerHTML = footer.innerHTML.repeat(8);
            </script>
        </div>
    </div>
</body>

</html>
