<!DOCTYPE HTML>
<html>

<head>
    <meta charset="utf-8">
    <title>
        Parametric Legs and Gaits
    </title>
    <link rel="stylesheet" type="text/css" href="/static/style/article.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Taviraj&family=Work+Sans&display=swap" rel="stylesheet">
    <link href="https://pvinis.github.io/iosevka-webfont/3.4.1/iosevka.css" rel="stylesheet" />

    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/base16/gigavolt.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    


    <script type="text/javascript">
        hljs.highlightAll();
    </script>
</head>

<body>
    <div class="bg-image"></div>
    <div id="page-wrapper">
        <div id="banner">
            <a href="/">
                home
            </a>
        </div>
        <div id="article-body">
            <div id="date">
                May 10, 2024
            </div>
            <div id="article-title">
                Parametric Legs and Gaits
            </div>
            <p>This is in service of a larger project that may or may not pan out, but for now I&#39;m tinkering around with a kind of &quot;creature generator&quot;.  This write-up is (hopefully) the first of several to come where I model and implement some part of a creature. Today we&#39;re getting into legs and the way they move.</p><h1>What is a leg even really?</h1><p>Long ago the only things that had bones were fish.  And then some of those fish got nuts and decided to get out of the water.  One thing led to another and now all sorts of bony leg-havers dominate the earth, and we call these things <em>tetrapods</em>.  There are also <em>arthropods</em> which have a different kind of bone-less leg, but we&#39;re going to ignore them for now.</p><p>Tetrapods are cool because if you compare the limb bones across different species, you will find that they are structurally very similar because they all descend from the same nubby proto-legs that those ancient fish developed.</p><p><img src="res/tetrapod_homology.png" title=""></p><p>Limbs can do all sorts of crazy things, but today we&#39;re just concerned with walking, so we&#39;re going to be specifically modelling some tetrapod <em>legs</em>. These legs generally fall into three categories:</p><ol start="1"><li><em>plantigrade</em> legs, where the metatarsals lie flat along the ground (e.g. human legs)</li><li><em>digitigrade</em> legs, where toes rest on the ground but the ankle is lifted up (e.g. cat legs)</li><li><em>unguligrade</em> legs, where the whole &quot;foot&quot; is lifted up almost vertically and the animal walks on what are effectively its toenails (e.g. horse legs)</li></ol><p><img src="res/leg_types.png" title=""></p><p>Naturally, since these three types of leg are made of the same parts and sort of blend into one another, I wanted to flesh out one parametric &quot;leg&quot; with a continuous state-space that encompassed all three.</p><p>To accomplish this, our creature&#39;s legs will have four bones/segments: femur, tibia, metatarsus, and toe (for simplicity I&#39;m going to use these names for both front and back legs).  The parameters for a leg will include the lengths of these segments, as well as an &quot;ankle lift&quot; factor which determines the angle between the metatarsus and the ground when standing.  Toes will always lie flat on the ground, and we can cheat a bit to get unguligrade legs by just reducing the toe length to zero.</p><p><img src="res/leg_parts.png" title=""></p><p>Let&#39;s think about how we actually want to implement these legs.</p><h1>Implementing legs</h1><p>Normally, a 3D character model in a game or animation software is accompanied by a bunch of bones that let you contort the mesh.</p><p>In practice, there are some bones (like the ones making up an arm or leg) that you, as the animator, don&#39;t always want to move one-by-one.  It&#39;s often more convenient to just put the hand or foot wherever you want it to be, and then have the rest of the arm or leg figure out how it needs to bend to make that work.  This process where a limb &quot;figures out&quot; how to pose itself is called <em>inverse kinematics</em> (IK).</p><p>It turns out that to make something walk or run, we also only really care about how its <em>feet</em> move, and so our legs will be completely driven by inverse kinematics.  Let&#39;s start with a simple example.</p><h2>A quick primer on IK</h2><p>The simplest practical example for understanding IK is a 2-link kinematic chain (e.g. a leg with one bone between the hip and knee, and another between the knee and foot). If we know the position of the hip and the position of the foot, we can use some trigonometry and analytically determine the angle and position of the knee.</p><p>I was going to make a little demo of this on Desmos but I found one that someone else made and it&#39;s a lot nicer than what I probably would&#39;ve done. So shout-out to whoever made this: <a href="https://www.desmos.com/calculator/zds5lmt401" title="">https://www.desmos.com/calculator/zds5lmt401</a></p><p>Here&#39;s the gist: the hip, foot, and knee form an imaginary triangle, and it turns out that we know all three side lengths of this triangle.  So using the law of cosines and some other trig you probably learned in high school, we can find the internal angles of the triangle and its rotation in space, and from there we can find the position of the knee joint.</p><p>This is obviously very cool and exciting, but our creatures&#39; legs will have more than two segments. You might think we can sneak in an extra link or two and keep solving everything analytically. Well guess what, we can&#39;t!  At least not without getting creative.  It turns out that when you add more degrees of freedom, the system becomes <em>redundant</em> and <em>underconstrained</em> meaning there are infinitely many solutions and our analytical approach no longer works.  I don&#39;t want to get into this too deeply here, but there are other <a href="https://motion.cs.illinois.edu/RoboticSystems/InverseKinematics.html" title="">good resources</a> you can check out if you want to really get into the math behind IK.</p><p>Of course there are ways to solve these types of redundant systems.  General purpose IK solvers usually employ some kind of numerical method that figures out the chain&#39;s pose using gradient descent or Netwon&#39;s method.  These work pretty well, and we will need to go this route eventually if we end up implementing body parts like necks and tails, but numerical methods tend to be more computationally expensive and offer less precise control.  It would be better to stay in the nice clean world of analytical solutions for as long as possible. And fortunately for us, that is still an option.  All we have to do is get a little creative.</p><h2>Getting a little creative</h2><p>The key to getting back to an analytical solution is eliminating the redundancy of our kinematic chain, meaning the &quot;extra&quot; joints are fixed or determined some other way.  Then we can run IK on the rest of the leg, which is no longer underconstrained. There&#39;s no one &quot;correct&quot; way to do this, so we&#39;re kind of just winging it and getting the leg&#39;s movements to look good.</p><p>First of all, I think we can safely ignore the toe bone in our actual kinematic chain.  It makes more sense for our &quot;end effector&quot; to be the joint between the metatarsus and the toe because that&#39;s what we want making contact with the ground.  The toe kind of just sticks out from there and it will move with the rest of the foot (we can always animate it later). So our actual kinematic chain is three links: femur, tibia, and metatarsus.</p><p>Since we decided that our &quot;ankle lift&quot; parameter would determine the angle between the metatarsus and the ground, we can start by fixing the orientation of the metatarsal bone. All we have to do is take the ankle lift and use some trig to find the x and y coordinate offset of the ankle joint from the foot target. And once we know our ankle position, we&#39;ve reduced the IK problem back down to two links, meaning it&#39;s solvable!</p><video autoplay loop muted>
    <source src="res/desmos_leg_1.webm" type="video/webm; codecs=vp9;vorbis">
</video>
<p>Obviously this isn&#39;t looking great.  The metatarsus is not rotating at all no matter how the rest of the leg moves. Let&#39;s at least have it inherit the rotation of the entire leg.  We&#39;ll find the angle between the y-axis and the straight line from the hip to the foot.  Then we can add this angle to the ankle lift before positioning the ankle joint.  We&#39;ll also use this angle to rotate the toe.</p><video autoplay loop muted>
    <source src="res/desmos_leg_2.webm" type="video/webm; codecs=vp9;vorbis">
</video>
<p>Now we&#39;re cooking.  I also want the ankle to bend in and out as the leg flexes and extends.  To do this, I&#39;m going to add another parameter to our leg that I&#39;m calling the &quot;natural bend&quot;.  We can figure out the maximum length of the leg at full extension, and the natural bend says what percentage of this is the leg&#39;s neutral resting length.  Then, if the distance from the hip to the foot is shorter or longer than this, the effective ankle lift decreases or increases accordingly.</p><video autoplay loop muted>
    <source src="res/desmos_leg_3.webm" type="video/webm; codecs=vp9;vorbis">
</video>
<p>This one is a little more subtle, but it particularly helps when the leg extends towards its maximum length.  There are still some edge cases where this looks kind of wonky, and you could certainly come up with some clever ways to make it look even better, but I&#39;m happy enough with it to leave it as is.</p><p><a href="https://www.desmos.com/calculator/vs8uhtdrfw" title="">Here&#39;s the fully functional leg on Desmos</a>.</p><p>I implemented this in Godot and put a dummy creature together with four of these legs.  The front legs work the same way as the back, but the knee joint bends in the opposite direction.  Also I made the toes lie flat whenever the foot was touching the ground, so that they look a little more realistic.</p><p><img src="res/creature_types.gif" title=""></p><p>Now let&#39;s put those legs to use.</p><h1>Gait</h1><p>A leg&#39;s main function is locomotion, and the particular way an animal moves it&#39;s legs as it locomotes is called a <em>gait</em>. Animals use different kinds gaits for all sorts of reasons, but movement speed tends to be the main one (a dog&#39;s feet move very differently between a walk and a run).</p><p>Each gait is a cyclical pattern within which each leg completes a full step — a step being composed of an airborne &quot;swing&quot; phase and a grounded &quot;stance&quot; phase.</p><p>The two most distinguishing factors of a gait are:</p><ol start="1"><li>The phase differences between each foot</li><li>The relative duration of the swing and stance portions of the step (sometimes called the duty factor).</li></ol><p>We&#39;ll be controlling the movement of our dummy&#39;s feet using oscillators that effectively break down into two periodic waves: one driving the front-back motion of the foot and the other (offset by a  \(\frac{\pi}{2}\) phase shift) driving the up-down motion.  For now these will just be plain sine waves. Let&#39;s take a look.</p><video autoplay loop muted>
    <source src="res/creature_walk_1.webm" type="video/webm; codecs=vp9;vorbis">
</video>
<p>Wow, look at him go!  This is obviously not a very realistic gait — all of the legs are synchronized with each other.  Let&#39;s fix that.</p><h2>Leg phase differences</h2><p>This part is pretty straight forward.  All we have to do is give some of the foot oscillators a phase shift so that they don&#39;t all step at the same time. We could set each one individually, but I prefer to generate the four offsets from a combination of two variables that we control: one phase offset between the front and back legs and another between the left and right legs.  These are additive so the difference between the front-left leg and rear-right leg is the sum of these two values.</p><p>Let&#39;s start by setting a phase offset of \(\pi\) between the left and right foot oscillators.</p><video autoplay loop muted>
    <source src="res/creature_walk_2.webm" type="video/webm; codecs=vp9;vorbis">
</video>
<p>Now we&#39;re getting somewhere!  This is a type of gait called a <em>pace</em> (although a pace is usually faster than this).  Let&#39;s add some offset between the front and back legs now.  Something around \(\frac{\pi}{2}\) should give us something that resembles a normal walk.</p><video autoplay loop muted>
    <source src="res/creature_walk_3.webm" type="video/webm; codecs=vp9;vorbis">
</video>
<p>This is already starting to look pretty good in my opinion.  We can get all sorts of very different looking gaits if we just mess around with these two phase offset values.</p><h2>Swing-stance ratio</h2><p>A step cycle is always split into a part where the foot is planted on the ground (the <em>stance</em> phase), and a part where the foot is in the air (the <em>swing</em> phase). So far in our creature&#39;s gaits, these have been equal in proportions. But in real life, faster gaits have shorter stance phases and longer swing phases, and slower gaits have the inverse.  If we want to our gait animations to look more convincing, we can&#39;t just speed up or slow down the whole animation: we need a way to manipulate our oscillators&#39; swing-stance ratio.</p><p>Let&#39;s first consider the sine wave driving the up-down motion of the foot. Clearly, if we want to bias towards a longer swing phase we will need to squash the part of this wave that is below zero and proportionally stretch out the part above zero (and vice versa for biasing in the other direction). There are probably a few good ways to accomplish this, but after fiddling around in Desmos for a while I came up with this mess of a function to replace our plain sine wave:</p><p>$$ f\left(x,k\right)=2\frac{k^{\sin\left(x\right)}-\frac{1}{k}}{\left(k-\frac{1}{k}\right)}-1 $$</p><p>\(x\) is the time input like before, and \(k\) is the &quot;skew factor&quot; whose range is \((0, \infty)\)</p><video autoplay loop muted>
    <source src="res/wave_1.webm" type="video/webm; codecs=vp9;vorbis">
</video>
<p>When \(k\) is very small, the wave becomes dominated by the positive part, and when \(k\) is very large, it becomes dominated by the negative part.  You can play around with this yourself <a href="https://www.desmos.com/calculator/8qtsamxsrh" title="">here</a>.</p><p>At \(k=1\) this function is actually undefined, but the wave function starts to become a normal sine wave as \(k\) approaches \(1\) from either side, so we can just handle that as an edge case in our implementation.</p><p>So now our foot can spend more time on the ground or in the air, but the front-back movement no longer syncs up with the up-down movement. The foot oscillator&#39;s other wave function needs to be modified as well.</p><p>The foot should ideally be moving forward throughout the swing phase and backward throughout the stance phase. If the foot is in the air for a shorter time than it is on the ground, it will have to move forward faster than it moves backwards, meaning we have to squeeze the rising slope of the wave, and stretch the falling slope.</p><p>Again I fiddled around in Desmos until I came up with a function that did roughly what I was looking for.  Here it is:</p><p>$$ f\left(x,k\right)=\frac{1}{k}\arctan\left(\frac{k\sin\left(x\right)}{1-k\cos\left(x\right)}\right) $$</p><video autoplay loop muted>
    <source src="res/wave_2.webm" type="video/webm; codecs=vp9;vorbis">
</video>
<p>Here the skew factor \(k\)&#39;s range is \((-1, 1)\), and effectively becomes a sawtooth wave at the extremes.  This is also undefined at \(k=0\), but just like our other function, it approaches a normal sine wave as \(k\) gets close to zero, so we can handle this edge case the same way.  You can play around with this function <a href="https://www.desmos.com/calculator/lldblzmvv0" title="">here</a>.</p><p>The final piece in this puzzle is matching up the two skew factors for the waves.  This was a little trickier than I wanted it to be.  You ideally want the x-intercepts of one wave to perfectly line up with the stationary points of the other wave, across all valid skew factors.  I wasn&#39;t quite able to do that, but I got close enough to have it look good in practice.  We&#39;ll take a bias factor \(b\) and use it to generate our skew factors as follows:</p><p>$$ k_{duty} = e^b $$</p><p>$$ k_{slope} = \frac{2}{\pi}\arctan\left(b\right) $$</p><video autoplay loop muted>
    <source src="res/wave_3.webm" type="video/webm; codecs=vp9;vorbis">
</video>
<p>\(b\) can be any real number, and skews both waves symmetrically for positive and negative values. I made another Desmos graph that that overlays the two waves <a href="https://www.desmos.com/calculator/ibki8wwuvm" title="">here</a>.</p><p>Now that we figured that out, we can upgrade our foot oscillator to use these functions instead of normal sine waves, and we can have &quot;swing-stance bias&quot; be another parameter we can put in our gait-making toolbox:</p><p>We can bias towards the swing phase for fast gaits like a gallop:</p><video autoplay loop muted>
    <source src="res/creature_walk_4.webm" type="video/webm; codecs=vp9;vorbis">
</video>
<p>and we can bias towards the stance phase for slow gaits like a walk:</p><video autoplay loop muted>
    <source src="res/creature_walk_5.webm" type="video/webm; codecs=vp9;vorbis">
</video>
<h2>Final touches: body movement</h2><p>At this point, the most important parts of the gait animation are done, but it&#39;s still looking pretty stiff.  Naturally you would expect the body itself to be a little more dynamic when the legs are moving all over the place, so let&#39;s make that happen. This write-up is already longer than it deserves to be, though, so I&#39;m going to be super brief here.</p><p>As you can probably see, our creature&#39;s body is made up of a bunch of segments, and the legs are attached to the ones at the very front and back.  Let&#39;s have these first and last segments bob up and down throughout the walk cycle.  You could probably do this with some kind of pseudo-physics simulation, but I just sample the two foot oscillators with a bit of offset, and use those values to set the height of the body segment and I think it looks pretty good.</p><p>We can also make the body segment turn left and right very slightly depending on which foot is forward and how far apart the left and right feet are.</p><p>Then after setting the position and orientation of these two body segments I generate a cubic Bezier curve between them and place the rest of the body segments along this curve.  This is a quick and dirty way to make the body look like it has a spine that is twisting and bending as the creature moves.</p><video autoplay loop muted>
    <source src="res/creature_walk_6.webm" type="video/webm; codecs=vp9;vorbis">
</video>
<h1>Wrapping up for now</h1><p>That pretty much covers everything I&#39;ve done so far.  I&#39;ve got more ideas that I want to incorporate, but I&#39;m trying to get better at finishing one thing at a time so that I can document my progress with these write-ups.</p><p>The next thing I&#39;d like to tinker with is combining our current gait animation with a more &quot;traditional&quot; kind of procedural walk animation, where the foot stays planted at some position while the body moves forward in space, and then quickly steps forward when the body gets too far away.  Currently our creature is kind of just moonwalking in place, but we obviously want him to be able to move around in some environment.  We could slide the whole creature forward as he&#39;s walking, but this starts to look really bad if the movement speed and animation aren&#39;t perfectly synced up.  And what if the ground is uneven or he&#39;s going up a flight of stairs?</p><p>Also tetrapods obviously aren&#39;t the only animals with legs.  There are all sorts of arthropods like bugs and crabs that have different kinds of legs.  And legs aren&#39;t even the only type of limb!  How would we implement wings, arms, and flippers?</p><p>Anyway, you can check out the source code of the final Godot project <a href="https://github.com/jehoz/legs-and-gaits" title="">here</a>.</p><p>(I&#39;ll try to get a web build of this up and running soon)</p>
        </div>
        <div id="spacer"></div>
        <div class="marquee">
            <div id="footer-inner">
                <span class="marquee-item">
                    <span>
                        thank you for reading
                    </span>
                    <img src="/static/img/templates/heart.gif"></img>
                </span>
                <span class="marquee-item">
                    <span>
                        please come back soon
                    </span>
                    <img src="/static/img/templates/wave.gif"></img>
                </span>
            </div>
            <script type="text/javascript">
                // duplicate the spans in the footer marquee 8 times
                let footer = document.getElementById("footer-inner");
                footer.innerHTML = footer.innerHTML.repeat(8);
            </script>
        </div>
    </div>
</body>

</html>
