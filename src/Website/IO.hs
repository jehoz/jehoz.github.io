{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TupleSections #-}

-- | Module: Website.IO
--
-- Functions for reading and writing website content from/to the filesystem.
module Website.IO where

import CMark (NodeType (CUSTOM_BLOCK, DOCUMENT))
import Control.Monad (filterM, forM, forM_)
import Control.Monad.Writer (WriterT, liftIO, runWriterT, tell)
import Data.Foldable (fold)
import Data.List (partition)
import qualified Data.Map as M
import Data.Maybe (fromMaybe)
import qualified Data.Text as T
import qualified Data.Text.IO as TIO
import qualified Data.Text.Lazy as TL
import System.Directory (copyFile, createDirectoryIfMissing, doesDirectoryExist, doesFileExist, listDirectory)
import System.Exit (die)
import System.FilePath (isExtensionOf, takeDirectory, (-<.>), (</>))
import Text.Blaze.Html (toHtml)
import Text.Blaze.Html.Renderer.Text (renderHtml)
import Text.Mustache (Template (name), automaticCompile, substitute)
import Website.Parsers
import Website.Types

-- | Monad for configuring the website generator
type Generator = WriterT Website IO

-- | Traverse through a directory, parse all @.md@ files as `Page`s and treat
-- the rest as static files.
loadContent :: FilePath -> Generator ()
loadContent dir = do
  contentPaths <- liftIO $ listSplitPaths dir
  let (mdFiles, otherFiles) = partition (isExtensionOf ".md" . relativePath) contentPaths
  pages' <- liftIO $ mapM loadPage mdFiles
  tell mempty {pages = pages', staticFiles = otherFiles}
  where
    loadPage spath = do
      mdText <- TIO.readFile (fullPath spath)
      case parsePage mdText of
        Left err -> die ("Error parsing " <> fullPath spath <> "\n" <> T.unpack err)
        Right page ->
          -- add other autogenerated page attributes here
          let attrs' =
                M.insert
                  "_url"
                  (PAText . T.pack $ "/" </> pathToUrl (relativePath spath) -<.> "html")
                  page.attrs
           in return $ page {sourcePath = spath, attrs = attrs'}

    -- replace backslash path separators with forward slashes in case the progream is run on Windows
    pathToUrl = map (\c -> if c == '\\' then '/' else c)

-- | Traverse through a directory, attempt to parse every file found as a
-- Mustache `Template`.
loadTemplates :: FilePath -> Generator ()
loadTemplates dir = do
  templatePaths <- liftIO $ listSplitPaths dir
  templates <- liftIO $ mapM loadTemplate templatePaths
  tell mempty {templateMap = M.fromList $ (\t -> (T.pack $ name t, t)) <$> templates}
  where
    loadTemplate spath = do
      res <- automaticCompile [parentDirectory spath] (relativePath spath)
      case res of
        Left err -> die (show err)
        Right template -> return template

-- | Set a directory as an output location where the generated website will be
-- written
renderTo :: FilePath -> Generator ()
renderTo dir = tell mempty {outputDirectories = [dir]}

-- | Generate all of the files for a static site in the given directory.
-- This involves rendering each page as an html file, and simply copying the
-- static files from the content directory (keeping the original directory
-- structure)
generateStaticSite :: Generator a -> IO ()
generateStaticSite generator = do
  (_, website) <- runWriterT generator

  -- render html pages
  putStrLn "Generating HTML pages"
  forM_ website.pages $ \p -> do
    let pageHtml = renderPage website.templateMap p
    forM_ website.outputDirectories $ \odir -> do
      let writePath = odir </> relativePath (p.sourcePath) -<.> "html"
      createDirectoryIfMissing True (takeDirectory writePath)
      putStrLn ("\t" <> writePath)
      TIO.writeFile writePath pageHtml

  -- make index page(s)
  let indexAttrs =
        PAMap $
          M.fromList [("pages", PAList (PAMap . attrs <$> website.pages))]
      indexHtml = case M.lookup "index.html" website.templateMap of
        Just t -> substitute t indexAttrs
        Nothing -> ""
  forM_ website.outputDirectories $ \odir -> do
    let writePath = odir </> "index.html"
    putStrLn ("Generating index page " <> writePath)
    TIO.writeFile writePath indexHtml

  -- copy static files
  putStrLn "Copying static files"
  forM_ website.staticFiles $ \spath -> do
    forM_ website.outputDirectories $ \odir -> do
      let toPath = odir </> relativePath spath
      createDirectoryIfMissing True (takeDirectory toPath)
      putStrLn ("\t" <> toPath)
      copyFile (fullPath spath) toPath
  where
    renderDoc = TL.toStrict . renderHtml . toHtml . content
    renderNoDoc = TL.toStrict . renderHtml . toHtml . stripDocTag . content
    stripDocTag n = replaceNode n DOCUMENT (CUSTOM_BLOCK "" "")

    renderPage templates p = fromMaybe (renderDoc p) $ do
      tname <- case M.lookup "template" p.attrs of
        Just (PAText n) -> Just n
        _ -> Nothing
      template <- M.lookup tname templates
      let attrs' = M.insert "body" (PAText $ renderNoDoc p) p.attrs
      return (substitute template attrs')

-- | Recursively get all files in the given directory as `SplitPath`s (where
-- the given directory is the parent).
listSplitPaths :: FilePath -> IO [SplitPath]
listSplitPaths parent = do
  rpaths <- listRelative parent
  return $ (parent,) <$> rpaths
  where
    listRelative dir = do
      paths <- listDirectory dir
      files <- filterM (doesFileExist . (dir </>)) paths
      dirs <- filterM (doesDirectoryExist . (dir </>)) paths
      rest <- forM dirs $ \d -> do
        rpaths <- listRelative (dir </> d)
        return $ (d </>) <$> rpaths
      return (files <> fold rest)
